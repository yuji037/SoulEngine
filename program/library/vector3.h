#pragma once

#include "DXUT.h"
#include "btBulletDynamicsCommon.h"
//namespace s2j {
//
//	struct vec3 {
//	public:
//
//		union {
//			struct {
//				float x;
//				float y;
//				float z;
//			};
//			float n[3];
//		};
//
//		vec3() : x(0.f), y(0.f), z(0.f) {}
//		vec3(const float _x, const float _y, const float _z) : x(_x), y(_y), z(_z) {}
//
//		vec3 operator - () const {
//			vec3 tmp;
//			tmp.x = -x;
//			tmp.y = -y;
//			tmp.z = -z;
//			return tmp;
//		}
//
//		vec3& operator += (const vec3& v) {
//
//			x += v.x;
//			y += v.y;
//			z += v.z;
//			return *this;
//		}
//
//		vec3 operator + (const vec3& v) {
//			vec3 tmp;
//			tmp.x = x + v.x;
//			tmp.y = y + v.y;
//			tmp.z = z + v.z;
//			return tmp;
//		}
//
//
//	};
//}

namespace s2j {
	//------------------------------------------------------------------------------------------------------------------------------------
	//
	// ３次元ベクトル
	//
	//------------------------------------------------------------------------------------------------------------------------------------
	typedef struct vec3
	{
	public:

		union {
			struct {
				float x, y, z;
			};
			struct {
				float mx, my, size;
			};
			float n[3];
		};

		//===========================================================================================
		// コンストラクタ
		//===========================================================================================
		vec3() : x(0.0f), y(0.0f), z(0.0f) {}
		vec3(const float _x, const float _y, const float _z) : x(_x), y(_y), z(_z) {}
		
		//D3DXVECTOR3& operator = (const vec3& v){
		//	D3DXVECTOR3 tmp;
		//	tmp.x = v.x;
		//	tmp.y = v.y;
		//	tmp.z = v.z;
		//	return tmp;
		//}
		//D3DXVECTOR3* operator = (const vec3* v) {
		//	D3DXVECTOR3 tmp;
		//	tmp.x = v->x;
		//	tmp.y = v->y;
		//	tmp.z = v->z;
		//	return &tmp;
		//}

		operator D3DXVECTOR3() {
			return D3DXVECTOR3(x, y, z);
		}
		operator btVector3() {
			return btVector3(x, y, z);
		}

		//===========================================================================================
		// 反転
		//===========================================================================================
		vec3 operator - () const;

		//===========================================================================================
		// 加算
		//===========================================================================================
		vec3& operator += (const vec3& v);
		vec3 operator + (const vec3& v) const;

		//===========================================================================================
		// 減算
		//===========================================================================================
		vec3& operator -= (const vec3& v);
		vec3 operator - (const vec3& v) const;

		//===========================================================================================
		// 積算
		//===========================================================================================
		vec3& operator *= (const float mul);
		vec3 operator * (const float mul) const;
		vec3& operator *= (const vec3& v);
		vec3 operator * (const vec3& v) const;

		//===========================================================================================
		// 除算
		//===========================================================================================
		vec3& operator /= (const float div);
		vec3 operator / (const float div) const;
		vec3& operator /= (const vec3& v);
		vec3 operator / (const vec3& v) const;

		//===========================================================================================
		// 比較
		//===========================================================================================
		bool operator == (const vec3& v) const;
		bool operator != (const vec3& v) const;

	} vec3;


	//===========================================================================================
	// name... vec3Normalize 
	// work... ベクトルの正規化
	// arg1... 正規化するベクトル
	// ret.... 演算結果
	// tips... none
	//===========================================================================================
	vec3 vec3Normalize(vec3& _v);

	//===========================================================================================
	// name... vec3Dot 
	// work... ベクトルの内積
	// arg1... ベクトル1
	// arg2... ベクトル2
	// ret.... 演算結果
	// tips... none
	//===========================================================================================
	float vec3Dot(const vec3& _v1, const vec3& _v2);

	//===========================================================================================
	// name... vec3Cross 
	// work... ベクトルの外積
	// arg1... 演算結果
	// arg2... ベクトル1
	// arg3... ベクトル2
	// ret.... none
	// tips... none
	//===========================================================================================
	vec3 vec3Cross(const vec3& _v1, const vec3& _v2);

	//===========================================================================================
	// name... vec3Angle 
	// work... ベクトルの角度
	// arg1... ベクトル1
	// arg2... ベクトル2
	// ret.... 演算結果 ( ラジアン )
	// tips... none
	//===========================================================================================
	float vec3Angle(const vec3& _v1, const vec3& _v2);

	//===========================================================================================
	// name... vec3Distance
	// work... ベクトルの距離
	// arg1... ベクトル1
	// arg2... ベクトル2
	// ret.... 演算結果 
	// tips... none
	//===========================================================================================
	float vec3Distance(const vec3& _v1, const vec3& _v2);

	//===========================================================================================
	// name... vec3Length
	// work... ベクトルの長さ
	// arg1... ベクトル
	// ret.... 演算結果 
	// tips... none
	//===========================================================================================
	float vec3Length(const vec3& _v);
	float vec3LengthSq(const vec3& _v);

	//===========================================================================================
	// name... vec3Lerp
	// work... ベクトルの線形補間
	// arg1... ベクトル1
	// arg2... ベクトル2
	// arg3... 線形補間パラメータ 0.0f 〜 1.0f
	// ret.... 演算結果
	// tips... ベクトル1 〜 ベクトル2 に補間
	//===========================================================================================
	vec3 vec3Lerp(const vec3& _v1, const vec3& _v2, float t);


	//===========================================================================================
	// name... vec3TransformCoord
	// work.... 指定された行列により３次元ベクトルを座標変換します
	// arg1.... 演算結果
	// arg2.... ベクトル
	// arg3.... マトリクス
	// ret....... none
	// tips.....  none 
	//===========================================================================================
	//void MatrixTransformCoord(  vec3 *_pOut, vec3 *_pvec, Matrix *_pMtx ) ;

	//===========================================================================================
	// name... vec3BezierSpline
	// work... 3次元空間上のベジェスプライン曲線補間
	// arg1... アンカー01 ( 始点 )
	// arg2... アンカー02 
	// arg3... アンカー03 
	// arg4... アンカー04 ( 終点 )
	// arg5... 0.0f ～ 1.0f 
	// ret.... 演算結果
	// note... none
	//===========================================================================================
	vec3 vec3BezierSpline(const vec3& _a1, const vec3& _a2, const vec3& _a3, const vec3& _a4, float t);

	const float PI = 3.14159265358979;

	inline float toDegree(float radian) {
		const float halfC = PI / 180.0f;
		return radian * halfC;
	}
}
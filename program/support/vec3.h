#pragma once

namespace t2k {

	//------------------------------------------------------------------------------------------------------------------------------------
	//
	// ３次元ベクトル
	//
	//------------------------------------------------------------------------------------------------------------------------------------
	typedef struct vec3
	{
	public:

		union {
			struct {
				float x, y, z ;
			} ;
			struct {
				float mx, my, size ;
			} ;
			float n[ 3 ] ;
		} ;

		//===========================================================================================
		// コンストラクタ
		//===========================================================================================
		vec3() : x(0.0f), y(0.0f), z(0.0f) {}
		vec3(const float _x, const float _y, const float _z) : x(_x), y(_y), z(_z) {}

		//===========================================================================================
		// 反転
		//===========================================================================================
		vec3 operator - () const ;

		//===========================================================================================
		// 加算
		//===========================================================================================
		vec3& operator += (const vec3& v) ;
		vec3 operator + (const vec3& v) const ;

		//===========================================================================================
		// 減算
		//===========================================================================================
		vec3& operator -= (const vec3& v) ;
		vec3 operator - (const vec3& v) const ;

		//===========================================================================================
		// 積算
		//===========================================================================================
		vec3& operator *= (const float mul) ;
		vec3 operator * (const float mul) const ;
		vec3& operator *= (const vec3& v) ;
		vec3 operator * (const vec3& v) const ;

		//===========================================================================================
		// 除算
		//===========================================================================================
		vec3& operator /= (const float div) ;
		vec3 operator / (const float div) const ;
		vec3& operator /= (const vec3& v) ;
		vec3 operator / (const vec3& v) const ;

		//===========================================================================================
		// 比較
		//===========================================================================================
		bool operator == (const vec3& v) const ;
		bool operator != (const vec3& v) const ;

	} vec3 ;


	//===========================================================================================
	// name... vec3Normalize 
	// work... ベクトルの正規化
	// arg1... 正規化するベクトル
	// ret.... 演算結果
	// tips... none
	//===========================================================================================
	vec3 vec3Normalize(vec3& _v) ;

	//===========================================================================================
	// name... vec3Dot 
	// work... ベクトルの内積
	// arg1... ベクトル1
	// arg2... ベクトル2
	// ret.... 演算結果
	// tips... none
	//===========================================================================================
	float vec3Dot(const vec3& _v1, const vec3& _v2) ;

	//===========================================================================================
	// name... vec3Cross 
	// work... ベクトルの外積
	// arg1... 演算結果
	// arg2... ベクトル1
	// arg3... ベクトル2
	// ret.... none
	// tips... none
	//===========================================================================================
	vec3 vec3Cross(const vec3& _v1, const vec3& _v2) ;

	//===========================================================================================
	// name... vec3Angle 
	// work... ベクトルの角度
	// arg1... ベクトル1
	// arg2... ベクトル2
	// ret.... 演算結果 ( ラジアン )
	// tips... none
	//===========================================================================================
	float vec3Angle(const vec3& _v1, const vec3& _v2) ;

	//===========================================================================================
	// name... vec3Distance
	// work... ベクトルの距離
	// arg1... ベクトル1
	// arg2... ベクトル2
	// ret.... 演算結果 
	// tips... none
	//===========================================================================================
	float vec3Distance(const vec3& _v1, const vec3& _v2) ;

	//===========================================================================================
	// name... vec3Length
	// work... ベクトルの長さ
	// arg1... ベクトル
	// ret.... 演算結果 
	// tips... none
	//===========================================================================================
	float vec3Length(const vec3& _v) ;

	//===========================================================================================
	// name... vec3Lerp
	// work... ベクトルの線形補間
	// arg1... ベクトル1
	// arg2... ベクトル2
	// arg3... 線形補間パラメータ 0.0f 〜 1.0f
	// ret.... 演算結果
	// tips... ベクトル1 〜 ベクトル2 に補間
	//===========================================================================================
	vec3 vec3Lerp(const vec3& _v1, const vec3& _v2, float t) ;


	//===========================================================================================
	// name... vec3TransformCoord
	// work.... 指定された行列により３次元ベクトルを座標変換します
	// arg1.... 演算結果
	// arg2.... ベクトル
	// arg3.... マトリクス
	// ret....... none
	// tips.....  none 
	//===========================================================================================
	//void MatrixTransformCoord(  vec3 *_pOut, vec3 *_pvec, Matrix *_pMtx ) ;

	//===========================================================================================
	// name... vec3BezierSpline
	// work... 3次元空間上のベジェスプライン曲線補間
	// arg1... アンカー01 ( 始点 )
	// arg2... アンカー02 
	// arg3... アンカー03 
	// arg4... アンカー04 ( 終点 )
	// arg5... 0.0f ～ 1.0f 
	// ret.... 演算結果
	// note... none
	//===========================================================================================
	vec3 vec3BezierSpline(const vec3& _a1, const vec3& _a2, const vec3& _a3, const vec3& _a4, float t) ;

	const float PI = 3.14159265358979 ;

	inline float toDegree( float radian ) {
		const float halfC = PI / 180.0f ;
		return radian * halfC;
	}

}